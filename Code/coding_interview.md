# Cracking the Coding Interview

## 급수표

| x | 2x | 근사값 | 메모리 요구량(byte) |
| --- | --- | --- | --- |
| 7 | 128 | | | 
| 8 | 256 | | | 
| 10 | 1,024 | 1,000 (천) | 1K | 
| 16 | 65,536 | | 64K | 
| 20 | 1,048,536 | 1,000,000 (백만) | 1MB | 
| 30 | 1,073,741,824 | 1,000,000,000 (십억) | 1GB | 
| 32 | 4,294,967,296 | | 4GB | 
| 40 | 1,099,511,627,776 | 1,000,000,000,000 (조) | 1TB | 

## 중요한 포인트

1. 면접관에게 문제의 모호한 부분에 대해서 묻는다.
	- 자료형, 데이터의 수, 어떤 가정이 포함되어 있는지, 사용자는 누구인지 
2. 알고리즘을 설계한다.
	- 시간과 공간 복잡도
	- 데이터의 수
	- 파생되는 이슈 살피기
	- 트레이드오프 
3. 가상코드 작성
4. 실제코드 작성
	- 자류 구조를 풍부하게 사용
	- 한가지 일을 하는 함수, 모듈성, 가독성, 정확성
5. 테스트를 하면서 오류 살피기
	- Worst case
	- Average case
	- 그 외 사용자 실수 에러

## 알고리즘 설계의 다섯가지 접근법

1. 예증 `Examplify`
	- 문제를 구성하는 특정한 사례들을 나열.
2. 패턴 매칭 `Pattern matching`
	- 풀어야 할 알고리즘이 어떤 문제와 유사한지 살피기
3. 단순화와 일반화
	- 다단계 접근법으로 진행.
	- 자료형이나 데이터 양과 같은 제약 조건들을 변경
4. 초기사례로부터의 확장 `Build by base case`
	- 초기 사례에 대해서 풀고, 다음 가정, 그 다음 가정, ...
	- n=1, n=2, n=3, ...
5. 자료구조 브레인스토밍
	- 일련의 자료구조를 차례차례 적용해보고 해결되는지 보기

## 자료구조

1. HashTable : key를 value에 대응 (hash function을 사용하므로 O(1) 접근)
	- 내부를 이진 탐색 트리로 구성하면 탐색에 O(log n)
2. List : 노드간의 연결로 이루어지는 구조
	- Runner 기법 (1 step pointer, 2 step pointer)
	- 재귀로 푸는 경우가 많음 (재귀는 스택에 쌓이므로, 공간복잡도 추가)
3. Stack (LIFO) / Queue (FIFO)
4. Tree
	- 이진 트리 vs 이진 탐색 트리
	- 균형 vs 비균형
	- 이진 트리 순회
		- 정순회 (왼, 중간, 오른), 후순회, 전순회
	- 트라이: n-차 트리 
5. Graph
	- 깊이 우선 탐색 `DFS` : 그래프 내의 모든 노드를 방문하고 싶다거나, 찾는 것을 발견할 때까지 모든 노드를 적어도 한 번은 방문하도록 하고 싶을 때.
	- 너비 우선 탐색 `BFS` : 큐를 사용해 순환적 형태로 구현하는 것이 보통은 가장 잘 동작

## 알고리즘

1. 재귀 `Recursive`
	- 접근법
		1. 상향식 : 간단한 것부터 하나씩 늘려가면서 진행
		2. 하향식 : N에 대한 문제를 분할하여 부분 문제로 나눌 수 있는지 생각
		3. 초기 사례로부터의 확장
	- 모든 재귀는 Loop로 풀 수 있음
2. 탐욕 `Greedy`
	- 각 단계에서 최선의 선택을 함
	- DP와 같이 쓰이며 서로 보완
	- 예) 스케쥴링 문제, 거스름 돈, 최소 신장 트리 등...
3. 동적 프로그래밍 `Dynamic Programming`
	- 재귀 문제를 풀 때와 같은 방향으로 접근하면서 Cache를 이용.
4. 정렬 `Sort`
	- 알고리즘들의 특성을 잘 파악하고 사용하는 것이 중요.
	- bucket sort, radix sort : 데이터의 수가 아주 많고, 범위가 한정적이여서 중복이 많은 정수에 적합. 소수에도 적용가능. O(n) and O(kn)
	- bubble sort, insertion sort : Avg O(n^2), Worst O(n^2), Memory O(1)
	- merge sort : Avg and worst O(n logn), memory depend each case
	- quick sort : Avg O(n logn), Worst(n^2), memory O(log n)
		- pivot 값이 한쪽에 치우져진 경우가 Worst case.
5. 탐색 `Search`
	- 주로 이진 탐색이 쓰인다. : O(log n), 정렬되어있는 경우에만 사용가능
	- 해시 테이블로 사용할 수도 있다

## Reference

[코딩 인터뷰 완전 분석](http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=19063480)
